# QuickCheck で性質テスト

Frege には性質テスト (propery-based test) を可能にする機能が備わっています。この機能で何ができるのかを少し見ていきましょう。

「種も仕掛けもあるんです」(Todo: 書いたらリンク貼る) では、以下のような関数 _f_ および _g_ を使用しました。

```
f :: [a] -> [a]  -- we should think of any such function
f  = reverse     -- that was our pick

g :: Int -> String
g x = show x ++ show x ++ show x
```

そして記事の結論として、

```
map g (f [1, 2, 3])
```

および

```
f (map g [1, 2, 3])
```

のいずれを選んでも同じ結果になるということがわかりました。

言い換えれば、テスト可能な性質 (個人的には _不変量_ という用語のほうが好きですが) を発見したというわけです。

Caption: JUnit 界隈の人向け

JUnit のバックグラウンドを持つ人がここまで読んできた場合、「テストケースはどこにあるのか？」が気になっているに違いありません。答えはこうです。「気にしなくてよい。ドメイン内からツールが勝手に、しかもランダムに抽出する」

私が最初この考え方に出会った時、まったく馬鹿げたことのように聞こえました。しかし、実際のところこのやり方には利点があります。また不安がる必要もなく、例えばコーナーケースをカバーするために、ハードコードしたひとつひとつのテストケースを実行することも依然として可能です。

以下に示したのが、Frege で QuickCheck を用いて関数の性質を定義するやり方です。

```
import frege.test.QuickCheck

commutativity xs = property ( map g (f xs) == f (map g xs) )
```

このように性質を定義するだけで、すぐにその性質が成り立つかどうか検査することができます。

```
quickCheck commutativity
```

結果は次のようになります。

```
+++ OK, passed 100 tests.
```

これはまさに驚くべきことです！ QuickCheck はどのようにして 100 個も生成すべきテストデータを知りえたのでしょうか？ 引数の型すら与えてはいないのに！ ここで登場するのが Frege の賢い型推論機構です。

_commutativity_ に対して推論された型は、REPL を使えば確認できます。

```
:t commutativity
[Int] -> Bool
```

それでは、Frege の型推論エンジンが考えたに違いない内容を、順を追って見てみましょう。

関数 _g_ は整数型の引数をひとつ取り、また `map g` の引数は _g_ の引数のリストでなくてはならないため、xs としてあり得るのは整数値のリストのみです。さらに _f_ は任意の型のリストに対して作用することができるため、追加で制約がかかることはありません。

Frege はコンパイル時に、より高度な推論を合理的に辿ってこれと同じ結論に至ります。

_xs_ の型が [Int] であるとわかっているため、QuickCheck はリスト型に任意のリスト値を (任意のサイズで) 生成させることができ、そして同様にリスト型は整数型に任意の整数値を生成させます。リストと整数はいずれも Arbitrary _型クラス_ のインスタンスであるため、この生成過程は型安全です。Arbitrary 型クラスとは、その型の任意の値を生成する方法が与えられている型クラスです。
