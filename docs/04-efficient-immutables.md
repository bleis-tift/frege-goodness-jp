# 素晴らしきかな不変性

関数型プログラミングの基礎となるのは、扱うもののほとんどが値である、ということです。値は決して変化しません。42 は 42 であり、そこに関数 `+1` を適用したとしても、返ってくる値が 43 であるというだけで 42 はやはり 42 のままです。

値は不変データなのです。

これは、数値の場合いたって当たり前のことです。しかし文字列はどうでしょう？ 広く使われる言語のほとんどは文字列を不変データとして扱います。この手法には、他のコードに中身を書き換えられる危険性なしでデータを安全に引き回すことができるという利点があります。

Frege では、不変性が持つこの利点を、リストやマップその他標準的に使用されるデータ構造だけでなく、ユーザが定義したものまでをも含む、すべての純粋 (*) なデータ構造に拡張します。

(*) データ構造が純粋であるとは、状態の変更やその他の副作用ををまったく行わないような型を持つことを指します。

オブジェクト指向畑の人にとっては、Frege の方針はまったく実用的でないように聞こえるかもしれません。あるいは広範囲なコピーが発生してメモリを食いつぶすのではと気になるかもしれません。以下では、値によるプログラミングを用いることで、_結果的に_驚くほど僅かな対価でいくつもの利点が得られることを明らかにしていきます。

## 自作データ構造

よくある、単純なデータ構造から始めましょう。苗字、名前、および考えるのに使っているプログラミング言語を保持する _Person_ を考えます。

Caption: 単純な Person データ型

```
data Person = Person { firstname, lastname, language :: String }

javaDierk   = Person "Dierk" "König" "Java"
```

これで、`Person` 型の値 `javaDierk` を生成すれば自動的に不変データになるのです！

実際には、ここで登場している言語機能は二つあります。

* Frege には代入がないため、上記の `=` は代入ではなく定義を表します。特に、`javaDierk` を再定義して他の `Person` を指すようにすることはできません。`javaDierk` を参照する人は誰であれ、この先ずっと「Java で考えるバージョン」の Dierk を参照することになります。

* `Person` の値自体を変更することはできません。しかし、すでにあるものをベースにして新しい値を生成することは可能です。

Caption: コピーを作成してフィールドを変更する

```
groovyDierk = javaDierk.{ language = "Groovy" }
fregeDierk  = javaDierk.{ language = "Frege"  }
```

Note: ここで登場した _レコード構文_ を扱うには面白い方法が色々とあり、先の記事で取り上げる予定です。

ここまでで、三つの相異なる `Person` 型の値が得られました。変更のたびに新しいコピーが生成されています。あたかも「セッター」のように見える部分は、むしろ _コピーコンストラクタ_ のような働きをします。

