# FizzBuzz 問題

もともとは子供の遊びですが、簡単なプログラミングの例題として使用される次のようなゲームがあります。

* 1、2、3、…と数を数える
* 3 回ごとに、数字の代わりに「fizz」と言う
* 5 回ごとに、数字の代わりに「buzz」と言う
* fizz と buzz との両方に該当するときは「fizzbuzz」と言う

この例は、動作としてはごく自明なものであるにもかかわらず、関数型設計とモジュール化について洞察を与えてくれます。必要なのは、思い切って従来のアプローチを問い直し、コンフォートゾーンから脱出する勇気だけです。

## 部品の準備

この問題を解決する方法はいくつもありますが、今回採用する方法は、命令型オブジェクト指向プログラミング方面の人にとってはやや馴染みがないかもしれません。無限リストを組み合わせて使います。

まず必要となるのは数字の無限リストです。頻繁に使うので、Frege では専用の書き方が用意されています。

Caption: すべての数字

```
[1..]
```

次に、fizz の条件を満たすために「3 個ごとの要素すべて」のようなパターンが必要です。3 個ごとに「fizz」になっており、残りはすべて空文字列であるような、無限に繰り返される文字列のリストを使用します。

Caption: 無限 fizz パターン

```
fizzes = cycle ["", "", "fizz"]
```

buzz のパターンがどのようになるかはもうわかるでしょう。

Caption: 無限 buzz パターン

```
buzzes = cycle ["", "", "", "", "buzz"]
```

これで必要な部品は揃いました。自然に仕様に沿ったものになっていることに注意しましょう。

## ルールを組み合わせる

揃えた部品は組み立てねばなりません。まず以下のようなパターンを作り出すために、fizz パターンと buzz パターンを組み合わせる必要があります。

```
"", "", "fizz", "", "buzz", "fizz", "", …​
```

これは、単に fizz パターンと buzz パターンを要素ごとに連結し、新しい無限リストを作り出せば OK です。

```
fizzes:  "", "", "fizz", "", "",     "fizz", "", ...
buzzes:  "", "", "",     "", "buzz", "",     "", ...
(++)  :  "", "", "fizz", "", "buzz", "fizz", "", ...
```

Caption: 無限 fizz-buzz パターン

```
pattern = zipWith (++) fizzes buzzes
```

このパターンからは、原始的なルールを組み合わせることで、新しい _ルール_ が作り出される様子が見て取れます。

マニア向け情報 : ここでは、文字列の先頭または末尾に空文字列を連結しても、元の文字列は変わらないという事実を用いています。実は文字列は連結について _モノイド_ 構造をなし、"" はその単位元です。またこの演算は結合則も満たしますが、これは 3 つ以上のルールを組み合わせようとした場合に必要になる性質です。

以上により、無限 fizzbuzz パターンが手に入りました。

## 数字と組み合わせる

それでは最終的な結果となる無限リストを得るために、さっきのパターンを数字の無限リストに重ね合わせます。

Caption: 最終的な　FizzBuzz 問題の解

```
fizzes   = cycle ["", "", "fizz"]
buzzes   = cycle ["", "", "", "", "buzz"]
pattern  = zipWith (++) fizzes buzzes
fizzbuzz = zipWith combine pattern [1..] where
    combine word number = if null word
                             then show number
                             else word
```

このような無限リストは極めて使い勝手がよいものです。無限リストを組み合わせる方法についてはすでに 2 回見てきましたが、フィルタリングしたり出力するために抜き出したりといったことも簡単にできます。

Caption: 無限リストの一部のみ表示する

```
main _ = do
    println $ take 5 $ drop 200 fizzbuzz

--  ["fizz", "202", "203", "fizz", "buzz"]
```

## 考察

Web 検索すると、以下に挙げるような解答が見つかるでしょう。実際に検索して一番目にヒットしたものです。

Caption: 命令型 FizzBuzz

```
public class FizzBuzz{
    public static void main(String[] args){
        for(int i= 1; i <= 100; i++){
            if(i % 15 == 0){
                System.out.println("FizzBuzz");
            }else if(i % 3 == 0){
                System.out.println("Fizz");
            }else if(i % 5 == 0){
                System.out.println("Buzz");
            }else{
                System.out.println(i);
            }
        }
    }
}
```

この命令型の解答の方が、大半の読者 (最近まで自分もそうでした) にとっては馴染みがあるでしょう。しかし、シンプルでモジュール化された Frege による解答と比較して、命令型の解答はよりややこしいものになっているという動かしがたい事実があります。

### 条件分岐

コード中に条件分岐が多くなるほどプログラムエラーが発生しやすくなります。条件分岐を入れ子にして使用した場合、エラーの可能性が (少なくとも自分にとっては) 指数的に増えます。

* 命令型：条件分岐 4 つ、うち 3 つは入れ子 (複雑度 3)
* Frege：条件分岐 1 つ (複雑度 0)

### 演算子

コード中に演算子が多くなるほどプログラムエラーが発生しやすくなります。演算子を組み合わせて使用した場合、エラーの可能性が (少なくとも自分にとっては) 指数的に増えます。

* 命令型：7 つ (i % 3 == 0 && i % 5 == 0 を使用した場合は 10)
* Frege：1 つ
