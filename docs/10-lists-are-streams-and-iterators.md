# リストに見るストリームとイテレータ

リストは (ちょうど Haskell と同じように) Frege では最もよく使われるデータ構造です。

Java のバックグラウンドから来た人にとっては、リストの性質に関して気になるところが多数あるかもしれません。

* メモリ空間の消費
* アクセスの方法
* 更新の方法
* 使用可能な機能
* イテレーション操作の方法
* ストリーム、イテレータ、シーケンス、コレクションとの関係

Frege では、これらの性質のうちかなりの部分が全く異なっており、はるかに汎用的で強力な形になっています。無限の大きさを持つデータを扱うことができ、ストリームとしても使用でき、そしてイテレータやシーケンスを代替することができるのです。

## メモリ消費

Frege のリストはしばしば、メモリをほとんど使用しません。正の整数全体からなる無限リストの例を見れば明らかです。

Caption: 無限リスト

```
integers = [1..]
```

無限に続くにもかかわらず、`integers` がメモリを食い潰すことはありません。また、無限でなくとも巨大なリストの場合も同様です。

Caption: 巨大なリスト

```
large = [1..100_000_000]
```

さて、これはレンジ指定リストでのみ使える特殊な機能だと思われるかもしれません。しかし遅延評価の恩恵により、個々の要素が何らかの方法で生成されるような任意のリストに対してこの機能が使用可能です。

Caption: その他の無限リスト

```
-- derive next value from predecessor
cardinals = iterate (+1) 1

-- derive by repeating
toggles   = cycle [true, false]

-- derive by mapping
data BigData    = BigData { number :: Integer }
infiniteBigData = map BigData [1..]
```

Java プログラマにとって、巨大なリストや Collection データ構造一般に対してもともと持っている不安を払拭するのは、いくらか訓練が必要です。

_心得その一_ : リストは評価されない限り、そのリストを定義するロジック (これを「サンク」と呼ぶ) の分しかメモリを占有しない。サンクを保持するために必要なメモリ空間はほぼゼロである。

_心得その二_ : 要素は必要となった時にだけ生成される。例えば `infiniteBigData` の 1000 番目の要素を問い合わせた場合、生成される BigData の値は (1000 個ではなく) ただ _一個_ のみである。
