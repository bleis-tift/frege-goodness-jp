# 第一回 : 無限に怠惰に後回し

ボードゲームはお互いの手番の繰り返しで成り立っており、それぞれの手番によって盤面の状態が更新されます。可能な着手は多数存在し、かつそのそれぞれに対して対戦相手による多数の返し手が存在するため、考えうるゲームの展開は盤面の状態による木構造をなします。

Caption: 着手と返し手による木構造

```
start
  move option 1
    counter-move 1
    counter-move 2
  move option 2
    counter-move 3
    counter-move 4
```

ゲームのルールにもよりますが、このようなゲーム木は無限に大きくなりえます。

これを Frege や Haskell のような遅延評価を行う関数型言語でモデリングする自然な方法は、木のサイズについてはまったく気にせず、どうやって木を構築するかにのみ注意を払うことです。ここでは木を生成することに注目し、生成される木を制限する作業は後回しにします。

以下に挙げたのは、任意の型「a」の値を要素とする木を構築する関数です。要素である「a」型の値をすべて `unfold` することで、再帰的に各ノードの子要素となるノードを生成します。

Caption: 再帰による一般的な木の構成

```
buildTree :: (a -> [a]) -> a -> Tree a
buildTree unfold a = Node a children where
    children = map (buildTree unfold) (unfold a)
```

ここでは、再帰が停止するための底となる場合分けや、木の大きさに対する制限については何も考えていません。しかし `buildTree` を呼んでもメモリや計算時間を使い果たしたりしないことに注意してください。言語が持つ遅延評価の機能によって、必要な時だけ子要素を生成するように考えられているのです。

与えられたデータ型 `Board` と、合法手を適用してすべての盤面を生成する関数 `move` を用いて具体化すると以下のようになります。

Caption: 盤面からすべての合法手を適用しゲーム木を生成する

```
gameTree :: Board -> Tree Board
gameTree board = buildTree moves board
```

この具体化は部分型を必要とせず、また依然として完全に型安全です。ここまで非侵入的にシステムを拡張してきましたが、さらにここからやはり非侵入的な方法でゲーム木のサイズを制限していきます。
