# 第二回 : 関数と合成による設計

第一回では、無限になりうるデータ構造を、実際にそのデータ構造を扱う関数から分離するために、遅延評価が役に立つことを見ました。ここでは同じ例を他の角度から復習しましょう。インクリメンタル開発を可能にする、関数を利用した設計についてです。

ここまで我々は、ゲームの盤面からなる木を構築する方法について扱ってきました。このゲーム木において子ノードは、プレイヤーが交互に手を進めることによって生み出される複数の盤面を表現しています。

次に打つべき最善手を見つけるために、盤面に何らかの値を付与しその値が最大値を取る盤面を選べるようにする必要があります。ここは _Double_ 型を採用して、コンピュータの勝利が確定した状態を `1` とし、逆を `-1` としましょう。盤面に対してこの値を静的に返す関数の型は以下のようになります。

Caption: 静的な評価関数

```
static :: Board -> Double
```

今回の議論を進める上では、特定のゲームに関して評価関数をどう実装するかは考える必要はありません。もし興味があれば、○×ゲームに対するシンプルな盤面評価の方法が [リンク先](http://github.com/Dierk/fregePluginApp/blob/game_only/src/frege/fregepluginapp/Minimax.fr) にあります。
