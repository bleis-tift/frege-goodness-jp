# 第二回 : 関数と合成による設計

第一回では、無限になりうるデータ構造を、実際にそのデータ構造を扱う関数から分離するために、遅延評価が役に立つことを見ました。ここでは同じ例を他の角度から復習しましょう。インクリメンタル開発を可能にする、関数を利用した設計についてです。

ここまで我々は、ゲームの盤面からなる木を構築する方法について扱ってきました。このゲーム木において子ノードは、プレイヤーが交互に手を進めることによって生み出される複数の盤面を表現しています。

次に打つべき最善手を見つけるために、盤面に何らかの値を付与しその値が最大値を取る盤面を選べるようにする必要があります。ここは _Double_ 型を採用して、コンピュータの勝利が確定した状態を `1` とし、逆を `-1` としましょう。盤面に対してこの値を静的に返す関数の型は以下のようになります。

Caption: 静的な評価関数

```
static :: Board -> Double
```

今回の議論を進める上では、特定のゲームに関して評価関数をどう実装するかは考える必要はありません。もし興味があれば、○×ゲームに対するシンプルな盤面評価の方法が [リンク先](http://github.com/Dierk/fregePluginApp/blob/game_only/src/frege/fregepluginapp/Minimax.fr) にあります。

Caption: オブジェクト指向設計との違い

ここで少し立ち止まって、もしオブジェクト指向設計だったらどうするかを考えてみましょう。 `Board` 型 に `static` メソッドを作りたくなるでしょう？ この方法ではメソッドとそれが扱うデータを合わせてカプセル化できるため、特にメソッドが盤面の内部で呼ばれる場合など、何らかの仮定をおいた場合には利点があるでしょう。

欠点としては、盤面をどのように扱うかに注意を向けたとき、それが _侵入的_ な変更となって現れる点が挙げられます。

Frege では、最終的な決定を保留したままであっても、データ構造と関数を同じ _モジュール_ 内に置くことによってカプセル化の利点を維持することができます。

そして次に取れる手について考える際、少なくとも一手読みの場合には、結果として得られる盤面の評価値が最大になるようなものを選ぶことになるでしょう。少し先まで読もうとすればすぐに、対戦相手がどんな行動を取るかも考える必要が生じます。合理的に考えて、対戦相手は逆に盤面の評価値が最低になるような最善手を打つだろうと仮定します。そして相手もこちらが最善手を打つだろうと仮定する、そんな風に進んでいきます。
