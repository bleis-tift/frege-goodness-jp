# 進化する高階関数とデータ型

第一回では、インクリメンタル開発について、および _非侵入的_ な状態を保つことの重要性について述べました。今回は、前回の最後の状態からコードの変更を行います。

Caption: 各段階の重なり

コードの変更は、我々が _侵入的_ であると宣言した対象ですが、最後に追加した分を変更することは許容されます。

コードに変更を入れることの問題点は、それに依存しているその他すべてのコードが危険にさらされる可能性があることです。これこそが _侵入的_ であると言われる所以です。_最後_ に追加した分に依存しているコードはおそらく存在しないため、安全に変更することができます。

理屈はともかく、与えられた盤面のミニマックス値を求めるために入れた最後の追加分を見てみましょう。

```
maxValue = maximize . static . prune 5 . gameTree
```

これはうまく動くのですが、もっと関数型 _らしく_ してみようと思います。

関数型プログラマは非常に早い段階で抽象化を導入したがること、また上記のコードには隠れた抽象が存在することはすでに見たとおりです。ここでは、盤面の木を Double 値の木にマップしていますが、木の構造はそのまま残ります。このことは _ファンクタ_ と呼ばれる抽象化の性質です。ファンクタに対しては、現在の構造を保ったまますべての要素に関数 _f_ を適用する一般された関数 _fmap_ を使用することができます。つまり今回の _Tree_ 型はこのようなファンクタなのです。

ファンクタとしての木の性質を使うために、_static_ の代わりに _fmap f_ を使います。

Caption: static を fmap static とする一般化

```
evaluateBy f = maximize . fmap f . prune 5 . gameTree

maxValue = evaluateBy static
```

_evaluateBy_ はパラメータ _f_ を取るようになったことに注意しましょう。盤面を引数として取り、_maximize_ が要求する _Ord_ を返すような関数なら何であっても _f_ として与えることができます。

_evaluateBy_ のような、他の関数をパラメータとして取る関数は __高階関数__ と呼ばれます。
高階関数は関数型プログラミングでは非常によく使用され、実際に過去の記事でも以前から特に注意もなく使ってきました。しかし今回のケースは一味違います。ここでは、非常に広く用いられる関数型機能であるところの高階関数を、_非侵入的な追加開発_ のお膳立てのために使用したのです。

## 新要件あらわる : 未来予測

ゲームで遊ぶのは楽しいものですが、ときどきコンピュータが、なぜそんな選択をしたのか理解しがたい手を打つように見えることがあります。コンピュータが何を考えているかについて推察し、それを明らかにすることができたら面白いのではないでしょうか。このためのアイデアとして、予測、すなわちゲームが進行した結果としてコンピュータが考える最終的な盤面を表示してみます。

Caption: コンピュータが自身の勝ちを知っている

この目的のために、ミニマックス値を与える盤面を見つける必要があります。結果としてこちらのほうが予測よりも簡単です。`evaluateBy` を使いますが、しかしもう `static` を渡すことはしません。その代わり、盤面を静的な評価値だけでなく、評価値と盤面自身との _組_ にマップする関数を渡します。

Caption: 静的な値と盤面を組にする

```
endValue = evaluateBy capture where
    capture board = (static board, board)
```

いい感じです。まず何より、完全に _非侵入的_ な追加になっています！ 既存のコードは全く変更していません。

次に、このコードは高階関数を用いており、新しい要件について予定したあったわけではないにもかかわらず、関数型のスタイルに則った非常に自然な結果になっています。
