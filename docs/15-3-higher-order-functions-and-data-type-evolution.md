# 進化する高階関数とデータ型

第一回では、インクリメンタル開発について、および _非侵入的_ な状態を保つことの重要性について述べました。今回は、前回の最後の状態からコードの変更を行います。

Caption: 各段階の重なり

コードの変更は、我々が _侵入的_ であると宣言した対象ですが、最後に追加した分を変更することは許容されます。

コードに変更を入れることの問題点は、それに依存しているその他すべてのコードが危険にさらされる可能性があることです。これこそが _侵入的_ であると言われる所以です。_最後_ に追加した分に依存しているコードはおそらく存在しないため、安全に変更することができます。

理屈はともかく、与えられた盤面のミニマックス値を求めるために入れた最後の追加分を見てみましょう。

```
maxValue = maximize . static . prune 5 . gameTree
```

これはうまく動くのですが、もっと関数型 _らしく_ してみようと思います。

関数型プログラマは非常に早い段階で抽象化を導入したがること、また上記のコードには隠れた抽象が存在することはすでに見たとおりです。ここでは、盤面の木を Double 値の木にマップしていますが、木の構造はそのまま残ります。このことは _ファンクタ_ と呼ばれる抽象化の性質です。ファンクタに対しては、現在の構造を保ったまますべての要素に関数 _f_ を適用する一般された関数 _fmap_ を使用することができます。つまり今回の _Tree_ 型はこのようなファンクタなのです。

ファンクタとしての木の性質を使うために、_static_ の代わりに _fmap f_ を使います。

Caption: static を fmap static とする一般化

```
evaluateBy f = maximize . fmap f . prune 5 . gameTree

maxValue = evaluateBy static
```

_evaluateBy_ はパラメータ _f_ を取るようになったことに注意しましょう。盤面を引数として取り、_maximize_ が要求する _Ord_ を返すような関数なら何であっても _f_ として与えることができます。

_evaluateBy_ のような、他の関数をパラメータとして取る関数は __高階関数__ と呼ばれます。
高階関数は関数型プログラミングでは非常によく使用され、実際に過去の記事でも以前から特に注意もなく使ってきました。しかし今回のケースは一味違います。ここでは、非常に広く用いられる関数型機能であるところの高階関数を、_非侵入的な追加開発_ のお膳立てのために使用したのです。
