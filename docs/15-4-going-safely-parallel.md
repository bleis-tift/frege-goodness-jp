# 第四回 : 並列実行で行こう

ここまでに、我々はインクリメンタル開発によって以下のような内容を実装してきました。

* 交互に手番が来るタイプのボードゲームに対する一般解
* ○×ゲームのルールに対する特殊解
* コンピュータが勝負の展開をどう考えているか確認できる追加の _予測_ 機能

ここで登場したコードは、結果として _純粋関数的_ でした。コード中に _単一代入_ (Todo: なら問題ないのでは？) や更新される必要のある _状態_ は存在せず、それゆえ並列実行したときに問題の原因となりうる可変な状態の共有も発生しません。さらに、コード中には _副作用_ もありません。

コードを書いたばかりなので、現に非純粋な書き方をしていないことは憶えています。しかし我々は、実装に関する前提知識がなくとも純粋性を確かめることができます。_型システムが教えてくれる_ のです！

## map は純粋

つまりこういうことです。我々の解法のエントリポイントは `map` 関数の呼び出しでしたが、_map_ のシグニチャは以下のようになっています。

Caption: map のシグニチャ

```
map :: ( α -> β ) -> [α] -> [β]
```

第一引数の `( α → β )`から見ていきます。

このシグネチャは、`map` の第一引数は制約のない任意の型 `α` から、やはり制約のない任意の型 `β` への関数であることを意味しています。この関数を _f_ と呼びましょう。`map` 関数は引数として与えられた関数 _f_ を `α` 型値のリストのすべての要素に適用することで `β` 型値のリストを生成しますが、_f_ の仕様については関知しません。

今回の場合、_f_ に当たるのは `(probe lookahead)` です。この関数により、与えられた _先読み_ 手数以内で各盤面の _探査_、すなわち盤面の評価もしくは勝敗が決する予測のいずれかが行われます。

任意の関数 _f_ を `α` 型の値からなるリストにマッピングしても、副作用を伴って実行される可能性はありません。もっとも近い状況としては、_f_ が型 `β` として IO アクションを返す場合でしょう。しかしこの場合であっても、IO アクションは _生成される_ だけであって _実行される_ わけではありません。`map` の実装がどのようになっていたとしても、このようなアクションを実行することはできません。これは `map` が `β` に関して _何も_ 仮定できず、したがって特にアクションであることを仮定できないからです。

別の言い方をすれば、___`map`_ のシグネチャは `map f` は純粋であることを表して__ おり、Frege の __型システム__ はその純粋性が呼び出しの連鎖全体に行き渡ることを強制しているのです！
