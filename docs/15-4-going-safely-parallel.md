# 第四回 : 並列実行で行こう

ここまでに、我々はインクリメンタル開発によって以下のような内容を実装してきました。

* 交互に手番が来るタイプのボードゲームに対する一般解
* ○×ゲームのルールに対する特殊解
* コンピュータが勝負の展開をどう考えているか確認できる追加の _予測_ 機能

ここで登場したコードは、結果として _純粋関数的_ でした。コード中に _単一代入_ (Todo: なら問題ないのでは？) や更新される必要のある _状態_ は存在せず、それゆえ並列実行したときに問題の原因となりうる可変な状態の共有も発生しません。さらに、コード中には _副作用_ もありません。

コードを書いたばかりなので、現に非純粋な書き方をしていないことは憶えています。しかし我々は、実装に関する前提知識がなくとも純粋性を確かめることができます。_型システムが教えてくれる_ のです！

## map は純粋

つまりこういうことです。我々の解法のエントリポイントは `map` 関数の呼び出しでしたが、_map_ のシグニチャは以下のようになっています。

Caption: map のシグニチャ

```
map :: ( α -> β ) -> [α] -> [β]
```

第一引数の `( α → β )`から見ていきます。

このシグネチャは、`map` の第一引数は制約のない任意の型 `α` から、やはり制約のない任意の型 `β` への関数であることを意味しています。この関数を _f_ と呼びましょう。`map` 関数は引数として与えられた関数 _f_ を `α` 型値のリストのすべての要素に適用することで `β` 型値のリストを生成しますが、_f_ の仕様については関知しません。

今回の場合、_f_ に当たるのは `(probe lookahead)` です。この関数により、与えられた _先読み_ 手数以内で各盤面の _探査_、すなわち盤面の評価もしくは勝敗が決する予測のいずれかが行われます。

任意の関数 _f_ を `α` 型の値からなるリストにマッピングしても、副作用を伴って実行される可能性はありません。もっとも近い状況としては、_f_ が型 `β` として IO アクションを返す場合でしょう。しかしこの場合であっても、IO アクションは _生成される_ だけであって _実行される_ わけではありません。`map` の実装がどのようになっていたとしても、このようなアクションを実行することはできません。これは `map` が `β` に関して _何も_ 仮定できず、したがって特にアクションであることを仮定できないからです。

別の言い方をすれば、___`map`_ のシグネチャは `map f` は純粋であることを表して__ おり、Frege の __型システム__ はその純粋性が _呼び出しの連鎖全体_ に行き渡ることを強制しているのです！ 純粋性に反する部分がないか、また基礎部分に対して後から変更を入れたメンテナがうっかり破壊してしまっていないか、自分自身で前に戻ってコードを確認する必要はありません。

それでは、`map` の代わりに`mapP` (`map` の並列実行版) を使って並列実行を行うと何が起こるでしょう？ `mapP` の型シグニチャは以下のようになっています。

Caption: mapP のシグニチャ

```
mapP :: ( α -> β ) -> [α] -> [β]
```

なんと `map` のシグニチャと _全く同じ_ です！ `map f` の純粋性について述べた上記の主張はすべて `mapP f` にも同様に当てはまります！

少し立ち止まって納得できるまで考えてみましょう。

## インクリメンタル開発における並列性

Frege によって、またもや _非侵入的な追加_ を行うことができました。_逐次_ 実行から _並列_ 実行へ、絶対に安全な方法によってです。純粋性と、それを型システムで扱うことによってこれが可能になったのです。もし他の有名 JVM 言語だったとしたら、どの言語でもこの種の変更は、検出困難なエラーが混入する可能性が_非常に高い_、__極めて__ 侵入的な (たとえ古いコードを全く編集しなかったとしても、演算の方式を変えるのは侵入的です) 変更になったでしょう。

そしてまた、この非侵入的な追加は _あらかじめ計画しておかなくとも_ 可能でした。Frege で普通に実装しただけであり、それが結果としてうまく機能したことになります。

ほとんどの場合において、`map` から `mapP` への変更は安全です。

しかし、すべての `map` の呼び出しを闇雲に並列実行に書き換える前に、考慮すべき点がふたつあります。

### 粒度

### 無限データ構造
