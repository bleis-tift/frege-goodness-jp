# 第四回 : 並列実行で行こう

ここまでに、我々はインクリメンタル開発によって以下のような内容を実装してきました。

* 交互に手番が来るタイプのボードゲームに対する一般解
* ○×ゲームのルールに対する特殊解
* コンピュータが勝負の展開をどう考えているか確認できる追加の _予測_ 機能

ここで登場したコードは、結果として _純粋関数的_ でした。コード中に _単一代入_ (Todo: なら問題ないのでは？) や更新される必要のある _状態_ は存在せず、それゆえ並列実行したときに問題の原因となりうる可変な状態の共有も発生しません。さらに、コード中には _副作用_ もありません。

コードを書いたばかりなので、現に非純粋な書き方をしていないことは憶えています。しかし我々は、実装に関する前提知識がなくとも純粋性を確かめることができます。_型システムが教えてくれる_ のです！

## map は純粋

つまりこういうことです。我々の解法のエントリポイントは `map` 関数の呼び出しでしたが、_map_ のシグニチャは以下のようになっています。

Caption: map のシグニチャ

```
map :: ( α -> β ) -> [α] -> [β]
```

第一引数の `( α → β )`から見ていきます。

このシグネチャは、`map` の第一引数は制約のない任意の型 `α` から、やはり制約のない任意の型 `β` への関数であることを意味しています。この関数を _f_ と呼びましょう。`map` 関数は引数として与えられた関数 _f_ を `α` 型値のリストのすべての要素に適用することで `β` 型値のリストを生成しますが、_f_ の仕様については関知しません。
