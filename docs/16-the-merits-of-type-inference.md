# 型推論のメリット

あまり知られていない Frege (あるいは Haskell) の利点として、型推論の方式が挙げられます。あまり知られていない理由のひとつは、数多の言語がそのファクトシートで型推論に触れているせいで、みな型推論を見ても面白い機能だと思わないからです。しかしながら型推論と一口に言っても、その意味するところは何も述べていないものからあらゆる内容を包含しているものまで様々です。

* いくつかの言語では単に、変数の定義と代入が同じ行で行われる時に型宣言を繰り返す必要がないことを指して型推論と呼んでいます。
* また別の言語では、型システムがリテラルによって宣言された変数の型を推論できることを指して型推論と呼んでいます。
* いくつかの型システムでは、引数の型が与えられている時に戻り値となる式の型を局所的に推論できます。
* Frege が属する ML 系の言語では、ヒンドリー・ミルナー型システムを活用します。これらの言語ではプログラム自体が式を組み合わせて作られており、プログラム中のすべての式ひとつひとつの型を、プログラム全体に至るまで、_大域的_ に推論することができます。型推論のためにプログラマ側からのヒントが必要となるのは、高階型が含まれるような極めて特殊な場合のみです。

それでは、このことがなぜ大きな違いを生むのかを例で見てみましょう。

## 最初はシンプルに

スタート地点となるもっとも簡単な例は、`f x` すなわち単に関数 _f_ を _x_ に一度適用するというものでしょう。この関数 (`once` とします) を `f x` で定義すれば、Frege がこの関数に対してどのような型を推論するか確認できます。

Caption: 単純な定義

```
once f x = f x
```

REPL なら `:type once`、Eclipse プラグインなら Ctrl + Space で推論された型を確認することができます。また、fregedoc ツールにより生成される API ドキュメントにも推論された型が記載されます。

Caption: 推論された型

```
once :: (b->a) -> b -> a
```

ここでは以下のような解釈が行われています。`f x` からわかるのは _f_ が関数であるということだけです。関数 _f_ は引数 _x_ をひとつ取ります。_x_ にも `f x` の戻り値にも型の制約は要求されていないため、単に型変数 _a_ および _b_ として扱われます。

_f_ が型 `b → a` を持つため、結果として _once_ のひとつめの引数の型は `b → a` であり、ふたつめの引数 _x_ の型は (_f_ に渡されているため) _b_ でなくてはならず、_once_ の戻り値の型は _f_ の戻り値と等しくなくてはならないため _a_ となります。

Frege が推論する型は可能な限り多相的になります。しかしこの多相性を _増やしたり減らしたり_ するとどうなるでしょう？

## もっと多相的に、あるいは非多相的に

上記のコードでは、型はまったく宣言せず型推論器に任せています。しかし必要であれば自分自身で型を宣言することも可能で、またそのほうがよい理由もいくつか存在します。

Caption: 型宣言を含める

```
once :: (b->a) -> b -> a
once f x = f x
```

まず明らかな利点として、コードを読んだ人が、IDE や REPL、あるいは API ドキュメントを確認するまでもなく即座に型がわかります。型宣言は、`once` がどんな型の上で定義されており、特定の型の引数を与えた時に戻り値として何を返すか (_f_ の戻り値の型と同じ) を示す、一種の内部的なドキュメントとなっています。
