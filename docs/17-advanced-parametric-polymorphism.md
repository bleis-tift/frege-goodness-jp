_Ingo Wechsung 氏による寄稿_

# パラメータ多相続論

プログラマは皆、同じことの繰り返しを避けようとするものです。共通のパターンに気づいたときはいつでも、一般化された解法を様々な形で (すなわち多相的に) 再利用できるように、そのパターンを抽象化しようとします。多相性を実現するには主に、オブジェクト指向における部分型、およびパラメータ付きの型の二つの手法があります。

__パラメータ多相__ は各種の主流プログラミング言語に導入されてからかなり経つものの、多くの人にとってこの用語は馴染みがありません。例えば Java では、__総称型__ という名前になっています。

基本となる考え方はシンプルです。関数やデータ型（あるいはメソッドやクラス）の型宣言において、型を __型変数__ として与え、具体的な型を後で決定することができます。このような型変数は特定の場所で __導入する__ ことができますが、その場所は言語によって異なります。例えば Java では明示的に型変数を導入することが必要になります。その後で、関数やデータ型を使用する際、導入した形式的な型変数は具体的な型 (そのコンテクストで有効な他の型変数の場合もある) で __インスタンス化__ されます。

以下に挙げたのは、Frege による古典的な _map_ 関数の抽象的な型宣言とその実装、および具体的な型として整数のリストを取った時の使用法です。

Caption: Haskell による古典的な map 関数

```
map ∷ (a→b) → [a] → [b]   -- can be implicit
map f []     = []
map f (x:xs) = f x : map f xs

-- instantiation is always invisible
sqrs = map (^2) [1..10]
```
また以下に、もしこれを Java で実装した場合にどうなるかを大まかに示します。

Caption: Java による map 関数の仮実装

```
// generic types are explicit
public static<A,B> List<B> map(Function<A,B> f, List<A> xxs) {
    // ... details omitted ...
}

// instantiation is visible
static List<Integer> sqrs = <Integer, Integer>map(
	x -> x*x,
	Arrays.asList(1,2,3,4,5,6,7,8,9,10));
```

Frege の型推論は `map` の型を完全に自動で推論できますが、通常の場合、明示的に型宣言を付けます (Eclipse プラグインのようなツールを使用すればワンクリックで可能です)。

重要なのは、Frege では、型変数の導入は _暗黙的_ に行うことができ、型変数のインスタンス化は常に目に見えない形で行われるということです。しかしながら、推論の結果 `map` は `sqrs` の右辺に現れる型である `(Int→Int) → [Int] → [Int]` でインスタンス化されます。ただし目に見えないだけあって、多くの Haskell や Frege のプログラマは、インスタンス化の存在すらまったく関知しません。

一方 Java では、メソッド宣言における型変数の導入は必ず明示せねばならず、そのインスタンス化とともにコード上で明らかに見て取れます。Java のコンパイラは、常にではありませんが、場合によってはインスタンス化された結果をうまく推論してくれることもあります。
