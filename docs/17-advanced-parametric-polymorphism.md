_Ingo Wechsung 氏による寄稿_

# パラメータ多相続論

プログラマは皆、同じことの繰り返しを避けようとするものです。共通のパターンに気づいたときはいつでも、一般化された解法を様々な形で (すなわち多相的に) 再利用できるように、そのパターンを抽象化しようとします。多相性を実現するには主に、オブジェクト指向における部分型、およびパラメータ付きの型の二つの手法があります。

__パラメータ多相__ は各種の主流プログラミング言語に導入されてからかなり経つものの、多くの人にとってこの用語は馴染みがありません。例えば Java では、__総称型__ という名前になっています。

基本となる考え方はシンプルです。関数やデータ型（あるいはメソッドやクラス）の型宣言において、型を __型変数__ として与え、具体的な型を後で決定することができます。このような型変数は特定の場所で __導入する__ ことができますが、その場所は言語によって異なります。例えば Java では明示的に型変数を導入することが必要になります。その後で、関数やデータ型を使用する際、導入した形式的な型変数は具体的な型 (そのコンテクストで有効な他の型変数の場合もある) で __インスタンス化__ されます。

以下に挙げたのは、Frege による古典的な _map_ 関数の抽象的な型宣言とその実装、および具体的な型として整数のリストを取った時の使用法です。

Caption: Haskell による古典的な map 関数

```
map ∷ (a→b) → [a] → [b]   -- can be implicit
map f []     = []
map f (x:xs) = f x : map f xs

-- instantiation is always invisible
sqrs = map (^2) [1..10]
```
また以下に、もしこれを Java で実装した場合にどうなるかを大まかに示します。

Caption: Java による map 関数の仮実装

```
// generic types are explicit
public static<A,B> List<B> map(Function<A,B> f, List<A> xxs) {
    // ... details omitted ...
}

// instantiation is visible
static List<Integer> sqrs = <Integer, Integer>map(
	x -> x*x,
	Arrays.asList(1,2,3,4,5,6,7,8,9,10));
```

Frege の型推論は `map` の型を完全に自動で推論できますが、通常の場合、明示的に型宣言を付けます (Eclipse プラグインのようなツールを使用すればワンクリックで可能です)。

重要なのは、Frege では、型変数の導入は _暗黙的_ に行うことができ、型変数のインスタンス化は常に目に見えない形で行われるということです。しかしながら、推論の結果 `map` は `sqrs` の右辺に現れる型である `(Int→Int) → [Int] → [Int]` でインスタンス化されます。ただし目に見えないだけあって、多くの Haskell や Frege のプログラマは、インスタンス化の存在すらまったく関知しません。

一方 Java では、メソッド宣言における型変数の導入は必ず明示せねばならず、そのインスタンス化とともにコード上で明らかに見て取れます。Java のコンパイラは、常にではありませんが、場合によってはインスタンス化された結果をうまく推論してくれることもあります。

Caption: この章のテーマは文法上の便利さではない！

この章の本題は、パラメータ多相と密接な関係があるにもかかわらずあまり知られていない概念、_高階型_ です。

このことは、FunctionalJava、HighJ、JavaSlang やその他、壮大で名高いいくつかの仕事において、基礎となった言語により抽象化機能が本質的に制限される理由に関して、ある示唆を与えてくれます。というのも、Java は少なくとも直接的には高階型サポートしていないからです。

## ジェネリクスでは多相性が不十分な場合

コード中で関数 (`reverse` や `drop n`) が、「最初にその関数を第一のリストに適用し、次に第二のリストにも適用し、それぞれの結果を _zip_ でまとめる」のような形で繰り返し使用されるとしましょう。

Caption: 同じパターンの繰り返し

```
zip (drop n  somelist) (drop n  otherlist)
zip (reverse somelist) (reverse otherlist)
```

このパターンが複数回登場する時、`reverse` や `drop n` はいずれも、ある型を同じ型に移すように見えます。

Caption: reverse と drop n の型

```
∀a.[a] → [a]  --(1)
```

この記事では意味を明確にするため、(1) のように型に明示的に量化子 (`∀a.`) をつけて表記します。実際のコードではこの量化子は必須ではなく、通常省略されます。

このような型を持つ関数で、よく使われるものを例として以下に挙げます。

Caption: ∀a.[a] → [a] 型の関数たち

```
reverse
tail
init
drop 10
take 20
id
```

意図するところは明らかです。二つのリストを組み合わせたいのですが、組み合わせる操作は両者に何らかの変換を施した後に行いたい、という状況です。一言で言えば

Caption: f を複数回使用する

```
zip (f somelist) (f otherlist)
```

という操作を適切な `f` について行い、かつ括弧と `f` の繰り返しを排除したい (`f` はそれ自身が長大な式になっている場合があることを思い出しましょう) ということです。

次のように書くための関数 `fzip` が必要であるように思われます。

Caption: fzip でパターンを抽象化

```
fzip f somelist otherlist
```

これを可能にする実装として、思い浮かぶのは以下のようなものでしょう。

Caption: まず試しに fzip を実装

```
fzip f [] [] = []
fzip f xs ys = zip (f xs) (f ys)
```

さて、何か簡単になったでしょうか？

しかしちょっと待ってください！ REPL に `fzip` の型を問い合わせると、こんな答えが返ってきます。

Caption: fzip に対して推論される型

```
∀a b.([a]->[b]) -> [a] -> [a] -> [(b,b)]
```

何らかの理由により、二つのリストの要素の型は同じであることが強制されています！

しかし、書き直そうとしている二つの式には、この制限はありません。そもそも、ここでリストを加工するために使おうとしている関数たちは要素の型を限定しておらず、任意のリストに対して動作するものです。

ともあれ現状では、一つ目のリストと二つ目のリストが同じ型を持たない場合に上で述べたような書き直しを行おうとすると、常に型エラーが発生してしまいます。例えば文字のリストと真偽値のリストを `fzip` することはできないのです。

では、`fzip` のどこがおかしいのでしょうか？

この場合について理解するため、インスタンス化についてどのように述べられていたかを思い出す必要があります。以下のような式において、

Caption: うまく動かない

```
fzip reverse ['a', 'b', 'c'] [false, true]
-- type error in expression [false,true]
--    type is : [Bool]
--    expected: [Char]
```

`reverse` はどんな型でインスタンス化されるべきでしょう？ 仮にその型として

```
[Char] → [Char]
```

を選んだとしたら、真偽値のリストを反転させることができないでしょう。そして

```
[Bool] → [Bool]
```

を選んだとしたら文字列のリストを反転させることができません。

上記の例では、コンパイラは文字列のリストが引数になっていることから `reverse` を `[Char] → [Char]` でインスタンス化することを選択し、それゆえ残った引数も同じ型を持つことを期待します。結局のところ、これが `fzip` の型に要求される条件であり、エラーメッセージの原因です。

しかし、一体なぜここでインスタンス化することが必要になるのでしょう？ これはヒンドリー・ミルナー型システムにおける型推論の制限によるものであり、ヒンドリー・ミルナー型システムは ML、Haskell、F# および Frege のような言語の型システムの基盤となっています。この制限によれば、 束縛されたラムダ式の値 (いわゆる「関数引数」) は _単相的_ であることが仮定されています。したがってインスタンス化が必要であり、さもなくば型推論は _非決定的_ になってしまいます。

## 型を階層付ける

言い方を変えれば、ヒンドリー・ミルナー流の (以下 HM と略す) 型推論で扱うことができるのは、ランク 1 の多相性だけです。また別の言い方をするならランク 1 の型は、HM アルゴリズムが推論できる多相型とちょうど一致します。これは実質的に、厳密に HM に沿った言語においては、高階関数は単相的もしくは単相的になるようにインスタンス化された関数しか引数に取れないということを意味します。残念なことに、`fzip` は ML や F# では書くことができないのです！

Caption: 高階型

ランク 2 の型は、ランク 1 の型が引数として、すなわち関数適用の列の左側に現れるような関数の型です。一般にランク _k_ の型は、引数の位置にランク _(k - 1)_ の型を持つような関数型になります。

ちょっと考えてみましょう！ 無限個のランクが存在し、そのランクそれぞれに無限個の型が属しているわけです。すごいでしょう？
